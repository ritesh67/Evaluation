It is a procedural language extension to the sql

Custom queries can be created, apply logic , portability is also there , tightly integrated ith sql,effiecient performance , more secure , object oriented support


PLSQL Structure 

Declaration(optional)
       declare
Executable commands
       begin
		Executable Commands
        end
Exception Handling(optional)
         exception 

Delimiters are symbols or predefined programs in plsql that help us to run something in plsql
% is attribute indicator, "character string attribute, .package component indicator, (,)expression or list delimiter , ,separation of items delimiter, : host variable indicator

Delimiter	Description
+, -, *, /	Addition, subtraction/negation, multiplication, division
%	Attribute indicator
'	Character string delimiter
.	Component selector
(,)	Expression or list delimiter
:	Host variable indicator
,	Item separator
"	Quoted identifier delimiter
=	Relational operator
@	Remote access indicator
;	Statement terminator
:=	Assignment operator
=>	Association operator
||	Concatenation operator
**	Exponentiation operator
<<, >>	Label delimiter (begin and end)
/*, */	Multi-line comment delimiter (begin and end)
--	Single-line comment indicator
..	Range operator
<, >, <=, >=	Relational operators
<>, '=, ~=, ^=	Different version of NOT EQUAL



CODE
DECLARE
 r constant real := 4;
 pi  constant real:=3.1415;
  Area constant real := (pi*r**2);
BEGIN 
  dbms_output.put_line('The area is:= '||Area);
exception
  when zero_divide then
  dbms_output.put_line(sqlerrm);
END;



DECLARE
 l real ;
 b real;
Area real;
BEGIN 
l := &l;
b := &b;
Area :=(l*b);
dbms_output.put_line('The area is:= '||Area);
END;


DECLARE
  grade varchar(5);
  result varchar(390);
BEGIN 
  grade := '&g';
  case 
    when grade = 'A' then result := 'excellent';
    when grade = 'B' then result := 'good';
    when grade = 'C' then result := 'not good';
    else result := 'please give valid value';
  end case;
  dbms_output.put_line(result);
END;


declare
  tab number;
  mul number:=0;
  result number:=1;
begin 
  tab := &tab;
  loop
    if mul>10 then exit;
    end if;
    result:=tab*mul;
    dbms_output.put_line(result);
    mul:=mul+1;
  end loop;
end;(exit condition)


DECLARE
  day number(5);
  result varchar(390);
BEGIN 
  day:= '&d';
  case 
    when day = '1' then result := 'Monday';
    when day = '2' then result := 'Tuesday';
    when day = '3' then result := 'Wednesday';
    when day = '3' then result := 'Thursday';
    when day = '3' then result := 'Friday';
    when day = '3' then result := 'saturday';
    else result := 'please give valid value';
  end case;
  dbms_output.put_line(result);
END;



DECLARE
  l_number NUMBER;
BEGIN
  l_number := &number;
  FOR i IN 1..1 LOOP
    DBMS_OUTPUT.PUT_LINE('The square of ' || l_number || ' is ' || (l_number * l_number));
  END LOOP;
END;

declare
  tab number;
  mul number:=1;
  result number:=1;
begin 
  tab := &tab;
  for mul in 1..10
    loop
      if mul>10 then exit;
      end if;
      result:=tab*mul;
      dbms_output.put_line(result);
      --mul:=mul+1;
    end loop;
end;


-> Anchor type event 
- FIELD type(columns) 

create table event(
    id number generated by default as identity,
    name varchar2(20) not null,
    location varchar2(30) not null,
    start_date date not null,
    end_date date not null,
    primary key(id)
);
insert into event(name,location,start_date,end_date) 
values('TechEd Asia','India Maharashtra',date '2022-09-01',date '2022-09-05');
insert into event(name,location,start_date,end_date) 
values('Computer Trends','India Andhra',to_date ('October 01,2019','MONTH DD,YYYY'),to_date ('October 04,2019','MONTH DD,YYYY'));
select * from event;
declare
    e_name event.name%type;
   e_location event.location%type;
begin 
    select name,location into e_name,e_location from event
    where id = 1;  
    dbms_output.put_line(e_name || e_location);
end;
 

->RECORD type event(TUPPLE) Advantage {The data type if modified then no need to change the datatype}

 create table event(
    id number generated by default as identity,
    name varchar2(20) not null,
    location varchar2(30) not null,
    start_date date not null,
    end_date date not null,
    primary key(id)
);
insert into event(name,location,start_date,end_date) 
values('TechEd Asia','India Maharashtra',date '2022-09-01',date '2022-09-05');
insert into event(name,location,start_date,end_date) 
values('Computer Trends','India Andhra',to_date ('October 01,2019','MONTH DD,YYYY'),to_date ('October 04,2019','MONTH DD,YYYY'));
select * from event;
declare
   r_event event%rowtype;
begin 
    r_event.id:= 4;
    r_event.name:= 'mothers day';
    r_event.location:= 'pune hadapsar';
    r_event.start_date:= to_date('NOVEMBER 03,2019', 'MONTH DD,YYYY');
	r_event.end_date:= to_date('NOVEMBER 04,2019', 'MONTH DD,YYYY');
INSERT INTO EVENT VALUES r_event;
end;



->SUBTYPE
declare 
Subtype name is Varchar(200);
Subtype message is varchar (300);
salutation name;
greeting message;

begin
salutation:='hello the one who must not be named';
greeting:='greetings to you';
    dbms_output.put_line(salutation || ' ' || greeting);
    
end;




SQL CURSORS(Implicit and explicit cursor)
%FOUND
%NOT FOUND
%IS OPEN
%ROWCOUNT

->CURSORS

CREATE TABLE customers (
    id INT,
    name VARCHAR(230),
    age INT NOT NULL,
    address VARCHAR(200),
    salary DECIMAL(18,2),
    PRIMARY KEY(id)
);

insert into customers(id,name,age,address,salary) values

(1,'Ramesh',32,'Ahmedabad',2000.00);

insert into customers(id,name,age,address,salary) values

(2,'khila',23,'pune',3400.00);

insert into customers(id,name,age,address,salary) values

(3,'ketan',43,'mumbai',10000.00);

insert into customers(id,name,age,address,salary) values

(4,'chaitali',31,'kolkata',6000.00);

insert into customers(id,name,age,address,salary) values

(5,'hardik',55,'lucknow',8000.00);

insert into customers(id,name,age,address,salary) values

(6,'Komal',22,'Mp',7500.00);
 

Select * from customers
DECLARE  
   total_rows number(2); 
BEGIN 
   UPDATE customers 
   SET salary = salary + 500; 
   IF sql%notfound THEN 
      dbms_output.put_line('no customers selected'); 
   ELSIF sql%found THEN 
      total_rows := sql%rowcount;
      dbms_output.put_line( total_rows || ' customers selected '); 
   END IF;  
END;     
Select*from customers



Procedures are called by using execute , using anonymous blocks , 
Square of numbers

create procedure squ2

    (x in number, y out number)
as
begin
	y := (x*x);

end squ2;
 
declare

	x number;

	y number;

begin

    x:=5;

	squ2(x,y);

	dbms_output.put_line(y);

end;

/
 



->cursor with exception

create table customers (

    customer_id number not null primary key,

    first_name varchar2(30) not null,

    last_name varchar2(30) not null,

    email varchar2(50)

)

insert into customers values (

    1,'sushant','pingale','ssp@gmail.com'

);

insert into customers values (

    2,'rohit','tupe','rrt@gmail.com'

);

select * from customers;
 
create procedure details

(p_id in number )

is

r_customers customers%rowtype;

begin 

	select * into r_customers from customers where customer_id=p_id;

	dbms_output.put_line(r_customers.first_name || ' ' || r_customers.last_name || ' ' || r_customers.email);

	exception when others then dbms_output.put_line(SQLERRM);

end;

/
 
execute details(1);
 



SQL SYNTAX FOR PROCEDURE 
Create [or replace]function function_name 
[(para_name[IN|OUT|INOUT]type[,....])]
return return_datatype
{IS|AS}
Begin
 <function body>
end function_name;



CREATE TABLE customers (
    id INT,
    name VARCHAR(230),
    age INT NOT NULL,
    address VARCHAR(200),
    salary DECIMAL(18,2),
    PRIMARY KEY(id)
);
insert into customers(id,name,age,address,salary) values

(1,'Ramesh',32,'Ahmedabad',2000.00);

insert into customers(id,name,age,address,salary) values

(2,'khila',23,'pune',3400.00);

insert into customers(id,name,age,address,salary) values

(3,'ketan',43,'mumbai',10000.00);

insert into customers(id,name,age,address,salary) values

(4,'chaitali',31,'kolkata',6000.00);

insert into customers(id,name,age,address,salary) values

(5,'hardik',55,'lucknow',8000.00);

insert into customers(id,name,age,address,salary) values

(6,'Komal',22,'Mp',7500.00);

Select * from customers

create function total_recordingss 
return number
IS
    total number := 0;
begin
    select count(*) into total from customers;
return total;
end total_recordingss;
/
declare 
custs number(2);
begin 
    custs := total_recordingss();
dbms_output.put_line('total customers are:='|| custs);
end;
/







PACKAGES PLSQL 
specification and body is invoked using dot operator (things without code trigger , procedure,specification)



CREATE TABLE customers (
 
    id INT,
 
    name VARCHAR(230),
 
    age INT NOT NULL,
 
    address VARCHAR(200),
 
    salary DECIMAL(18,2),
 
    PRIMARY KEY(id)
 
);
 
insert into customers(id,name,age,address,salary) values
(1,'Ramesh',32,'Ahmedabad',2000.00);
insert into customers(id,name,age,address,salary) values
(2,'khila',23,'pune',3400.00);
insert into customers(id,name,age,address,salary) values
(3,'ketan',43,'mumbai',10000.00);
insert into customers(id,name,age,address,salary) values
(4,'chaitali',31,'kolkata',6000.00);
insert into customers(id,name,age,address,salary) values
(5,'hardik',55,'lucknow',8000.00);
insert into customers(id,name,age,address,salary) values
(6,'Komal',22,'Mp',7500.00);
 
create package cust_sal as
	procedure find_sal(c_id customers.id%type);
end cust_sal;
/
 
 
create or replace package body cust_sal as
	PROCEDURE find_sal(c_id customers.id%type) IS
	c_sal customers.salary%TYPE;
	BEGIN
		select salary into c_sal 
		from customers
		where id = c_id;
		dbms_output.put_line('Salary ' || c_sal);
	END find_sal;
END cust_sal;
/







